(n & (n - 1)) == 0
は、与えられた整数 n が「2 の累乗」であるか（あるいは 0 であるか）を調べるためによく使われるビットトリックです。以下のように動作を理解できます。

ビット操作の性質

整数 n を 2進数で見ると、例えば

ini
コードをコピーする
n = 0b...1000...000  (ちょうど 1つのビットだけが 1)
という形のものが「2 の累乗」に対応します。

n - 1 を計算すると、その「1」が立っている位置より下のすべてのビットが反転します。
例：

cpp
コードをコピーする
n     = 0b00100000  // 32
n - 1 = 0b00011111  // 31
AND 演算 (&) の結果

上の例で n & (n - 1) を見ると、

コードをコピーする
0b00100000
& 0b00011111
0b00000000

markdown
コードをコピーする
となり、すべてのビットが 0 になります。  
- `n` の中に 1 が **ちょうど一つ**しかなければ、必ず `(n & (n - 1))` は `0` になります。

2つ以上のビットが立っている場合

たとえば

cpp
コードをコピーする
n     = 0b00101000  // 40 (ビットが 2 か所で 1)
n - 1 = 0b00100111  // 39
n & (n - 1) = 0b00100000  // 32 非ゼロ
この場合は 0 以外の値が返り、式全体は false になります。

n == 0 の扱い

無符号整数 (u32 など) で n = 0 のとき、

rust
コードをコピーする
n - 1  // = 0u32.wrapping_sub(1) = 0xFFFF_FFFF
n & (n - 1) = 0 & 0xFFFF_FFFF = 0
したがって (0 & (0 - 1)) == 0 も true になります。

「2 の累乗だけを検出したい」場合は、n != 0 を追加して

rust
コードをコピーする
n != 0 && (n & (n - 1)) == 0
とすることで 0 を除外できます。

Rust による例
rust
コードをコピーする
/// n が 2 の累乗かどうかを返す（0 は false とみなす）
pub fn is_power_of_two(n: u32) -> bool {
    n != 0 && (n & (n - 1)) == 0
}

fn main() {
    for &x in &[0u32, 1, 2, 3, 4, 16, 18, 32] {
        println!("{} -> {}", x, is_power_of_two(x));
    }
}
// 出力例:
// 0 -> false
// 1 -> true
// 2 -> true
// 3 -> false
// 4 -> true
// 16 -> true
// 18 -> false
// 32 -> true
このように、(n & (n - 1)) == 0 という式は「最下位に立っている 1 ビットを消す」性質を利用して、ビットが一つしか立っていないかどうかを高速に判定するトリックです。






