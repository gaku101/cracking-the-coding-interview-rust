///  1. 最下位側の連続する 0 の個数 (c0) と、その直後の 1 の個数 (c1) を数える
///  2. 位置 p = c0 + c1 を求め、p 番目のビットを 1 に反転
///  3. p より下位のビットをすべてクリアし、(c1-1) 個の 1 を右側に詰める
///
/// n のビット全体（32 ビット）のうち、解が存在しない場合は None を返す。
pub fn get_next_larger(n: u32) -> Option<u32> {
    let mut c = n;
    let mut c0 = 0;
    let mut c1 = 0;

    // 末尾側の 0 の個数をカウント
    while (c & 1) == 0 && c != 0 {
        c0 += 1;
        c >>= 1;
    }
    // 連続する 1 の個数をカウント
    while (c & 1) == 1 {
        c1 += 1;
        c >>= 1;
    }

    // 全ビット数に近い場合、もしくは n が全 1 である場合は次の数は存在しない
    let p = c0 + c1;
    if p == 31 || p == 0 {
        return None;
    }

    let mut next = n;
    // p 番目のビット（右端から数えて）を 1 にセットする
    next |= 1 << p;
    // p より下位のビットをクリアする
    next &= !((1 << p) - 1);
    // (c1-1) 個の 1 を右側に詰める
    next |= (1 << (c1 - 1)) - 1;

    Some(next)
}

///  1. まず、末尾側の連続する 1 の個数 (c1) を数える
///  2. 次に、その直後の連続する 0 の個数 (c0) を数える
///  3. 位置 p = c0 + c1 を求め、p 番目のビットを 0 に反転
///  4. p 以下（右側）のビットをすべてクリアし、(c1+1) 個の 1 を適切な位置に配置する
///
/// n のビット全体内で解が存在しない場合は None を返す。
pub fn get_next_smaller(n: u32) -> Option<u32> {
    let mut temp = n;
    let mut c1 = 0;
    let mut c0 = 0;

    // 末尾側の連続する 1 の個数をカウント
    while (temp & 1) == 1 {
        c1 += 1;
        temp >>= 1;
    }

    // もし n がすべて 1 ならば、次に小さい数は存在しない
    if temp == 0 {
        return None;
    }

    // その後の連続する 0 の個数をカウント
    while (temp & 1) == 0 && temp != 0 {
        c0 += 1;
        temp >>= 1;
    }

    let p = c0 + c1;  // 変更すべきビットの位置

    let mut prev = n;
    // p 以降（右側）のビットをすべてクリアする
    prev &= (!0) << (p + 1);
    
    // (c1+1) 個の 1 の塊を作成する。これは、先にある 1 のうち 1 ビットを減らすため
    let mask = (1 << (c1 + 1)) - 1;
    
    // このマスクを、c0-1 だけ左にシフトした位置に配置し、n に OR する
    // ここで c0 は、トレイリングの 0 の個数なので、適切な位置に 1 を詰めることになる
    prev |= mask << (c0 - 1);

    Some(prev)
}



/*
& はビット単位の AND 演算子で、
両方の対応するビットが 1 である場合に、そのビットが 1 となる値を返します。
*/

/*
計算量は、各ビットを 1 回ずつ確認するため Time Complexity: O(1)（整数のビット数は定数個＝32 または 64 ビットと仮定）
*/