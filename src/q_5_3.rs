pub fn flip_bit_to_win(n: u32) -> u32 {
    if n == !0 {
        return std::mem::size_of::<u32>() as u32 * 8;
    }

    let mut current_len = 0; // 現在連続している1の長さ
    let mut previous_len = 0; // 直前のブロックでの1の長さ
    let mut max_len = 1; // 結果の最長長さ（少なくとも1）
    let mut num = n;

    for _ in 0..32 {
        if num & 1 == 1 {
            current_len += 1;
        } else {
            // ビットが0なら、次のビットをチェックして
            // もし次が1なら previous_len = current_len、そうでなければ0にリセット
            previous_len = if (num >> 1) & 1 == 1 { current_len } else { 0 };
            current_len = 0;
        }
        // 反転したと仮定した長さを計算して最大値を更新
        max_len = max_len.max(previous_len + 1 + current_len);
        num >>= 1;
    }
    max_len
}
/*
時間計算量: O(b)

ここで b はビット数（32ビットなら32）。ビット長に比例する。

空間計算量: O(1)

使用する補助変数は定数個のみ。
*/

/*
>>= 演算子

>>= は「右シフト代入演算子」（right‑shift AND assign operator）です。

これは以下の２つの処理をまとめた省略形です：

num >> 1 （変数 num のビットを右に 1 ビットシフト）

その結果を再び num に代入

展開すると次のように書かれます：

rust
コードをコピーする
num = num >> 1;
ビットシフト演算（>>）

>> は「右ビットシフト演算子」で、数値をビット単位で右にずらします。

たとえば、0b1100 >> 1 は 0b0110（10進で 12 → 6）になります。

型によって振る舞いが異なります：

符号なし整数（u8, u16, u32…） では論理右シフト（左側に 0 を詰める）

符号付き整数（i8, i16, i32…） では算術右シフト（符号ビットを保持）
*/

/*
num & 1 は整数 num の最下位ビット（LSB）だけを取り出します。

*/

/*
num >>= 1; は内部的に

rust
コードをコピーする
num = num >> 1;
と同じで、論理右シフトを行います。

元のビット列: 0b11011101111

右に1ビットシフト → 最下位ビット（LSB）が切り捨てられ、左端には 0 が詰められる

結果:

コードをコピーする
0b11011101111 >> 1  ==  0b01101110111
慣習的に先頭の不要な 0 を省くと

text
コードをコピーする
0b1101110111
になります。

（10進数で見ると 1775 >> 1 = 887 です）

*/