#[derive(Debug)]
pub struct MinStack<T>
where
    T: Ord + Copy,
{
   // メインのスタック
   stack: Vec<T>,
   // 現在の最小値を保持するスタック
   min_stack: Vec<T>,
}

impl<T> MinStack<T>
where
    T: Ord + Copy,
{
    pub fn new() -> Self {
        MinStack {
            stack: Vec::new(),
            min_stack: Vec::new(),
        }
    }

    pub fn push(&mut self, value: T) {
        self.stack.push(value);
        // min_stack が空の場合、または新しい値が現在の最小値以下の場合は、min_stack にもプッシュ
        if self.min_stack.is_empty() || value <= *self.min_stack.last().unwrap() {
            self.min_stack.push(value);
        }
    }

    pub fn pop(&mut self) -> Option<T> {
        if let Some(popped) = self.stack.pop() {
            // ポップした値が最小値と等しい場合、min_stack からもポップ
            if popped == *self.min_stack.last().unwrap() {
                self.min_stack.pop();
            }
            Some(popped)
        } else {
            None
        }
    }

    pub fn min(&self) -> Option<T> {
        self.min_stack.last().copied()
    }
}

/*
時間計算量
push: O(1)
pop: O(1)
min: O(1)

空間計算量
最悪の場合 、全ての要素が min_stack にも追加されるため、O(n)

*/

/*
where T: Ord + Copy は、Rustのジェネリック型 T に対して、特定のトレイト（性質）を実装している必要があるという制約（境界条件）を指定しています。ここで指定されている2つのトレイトについて詳しく説明します。

Ord トレイト

意味:
Ord トレイトは、型 T の値が順序付けられる（大小比較ができる）ことを保証します。
理由:
この実装では、スタック内の最小値を取得するために、<= などの比較演算子を使用して値同士を比較します。
そのため、T が大小比較可能である必要があり、Ord トレイトが要求されます。
Copy トレイト

意味:
Copy トレイトは、型 T の値が浅いコピー（ビット単位のコピー）で済むことを保証します。
すなわち、所有権を移動せずに値を簡単にコピーできる性質を持っています。
理由:
このコードでは、スタックから値を取り出したり、補助スタック（min_stack）のトップ要素をコピーしたりする際に、値をコピーする必要があります。
T が Copy トレイトを実装していることで、所有権の移動やクローン処理を気にせずに値を安全かつ効率的にコピーできるようになります。
まとめると、

Ord は値の比較に必要な性質を提供し、
Copy は値の効率的なコピーを可能にします。
この両方のトレイトを T に要求することで、MinStack 構造体内での操作（push、pop、min）が安全かつ効率的に行えるようになっています。
*/

/*
self.min_stack.last()

これは min_stack という Vec<T> の最後の要素（つまりスタックのトップ）への参照を取得するメソッドです。
戻り値の型は Option<&T> となります。スタックが空の場合は None、そうでなければ Some(&T) が返されます。
.unwrap()

Option 型に対して使用するメソッドで、Some の中の値を取り出します。
ここでは、スタックが空でない（必ず要素が存在すると仮定している）ので、Some(&T) から &T を取り出します。
もしスタックが空だった場合は、unwrap() によってプログラムがパニックを起こしますので、使用には注意が必要です。
*

* 演算子はデリファレンス演算子で、参照 &T を実際の値 T に変換します。
これにより、&T から値そのものを得ることができます。
まとめると、

self.min_stack.last() で補助スタックの最後の要素（参照）を取得し、
unwrap() で Option からその参照を取り出し、
* によってその参照をデリファレンスして実際の値を得る、という流れになります。
*/

/*
last() は Rust の標準ライブラリに組み込まれているメソッドで、Vec<T> 型やスライス（[T]）で利用できます。
具体的には、Vec<T> は内部的にスライスとして扱われるため、last() を呼び出すと、ベクタの最後の要素への参照が Option<&T> として返されます。
スタックの実装例では、補助スタック（min_stack）の最後の要素（つまり、スタックのトップ）を取得するために last() を利用しています。
*/

/*
単に現在の最小値を一つだけ保持する変数（型 T）ではなく、Vec<T>（スタック）を使う理由は、履歴管理の必要性にあります。

具体的には：

スタックの状態の変化
スタックに要素を追加（push）するたびに最小値が更新される可能性があります。また、pop操作によって最小値が取り除かれると、以前の状態（つまり直前の最小値）に戻す必要があります。
そのため、各状態での最小値を順次記録しておき、pop時に元の最小値に戻すことができるようにする必要があります。

履歴を保持するための構造
単一の T だと、現在の最小値のみしか保持できませんが、popしたときに「前の最小値」が何であったかを知る手段がなくなります。
Vec<T> を使うことで、各 push のときに現在の最小値を記録し、pop時にその履歴から最新のものを取り出すことで、常に正しい最小値を O(1) で得ることができます。

まとめると、単に最小値を返すだけではなく、スタックの操作に合わせて最小値が変化する履歴を管理するために、min_stack は Vec<T> として実装されています。







*/